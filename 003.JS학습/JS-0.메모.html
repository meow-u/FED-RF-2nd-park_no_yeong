<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<script>` 

[ 조건연산자(삼항연산자) ]

    - if문과 유사하게 조건에 맞으면 실행할 수 있는
    코드를 구분해 주는 연산자다!
    -> 개발자들이 코드를 줄여쓸때 if문 대신에
    많이 사용한다! 사랑한다!!!
    
    ((구문구조))
    -----------------------------------
    조건식 ? 실행문1 : 실행문2 ;
    -----------------------------------
    
    -> 조건식이 true이면 실행문1을 실행하고
    조건식이 false이면 실행문2를 실행한다!
    
    예) 비?집:놀이동산;
    -> 비가오면 집에 있고 안오면 놀이동산간다!
    -> 항목이 3개여서 삼항연산자라고도 함!

    __________________________________________________

    [ 참고 ]
    인터폴레이션 구역( $ {} )에는 표현식만 쓸 수 있다!
    표현식은 그자리에 값이 출력되는 식을 말한다!
    
    따라서 제어문은 쓸 수 없다!
    수식, 삼항연산자,리턴있는함수 이런것들을 쓸 수 있다!
    __________________________________________________
    
    

[제어문]    
[ if문 ]
    - 조건문을 검사하여 true이면
    중괄호안의 코드가 실행되는 제어문
    
    ((구문구조))
    -----------------------------------------------
    if(조건문){
        실행코드
    }
    else if(조건문){
        실행코드 
    }
    ...
    else{
        실행코드
    }
    -----------------------------------------------
    ((구문해석))
    1. if문은 단독으로 따로 사용가능
    2. else if문은 if문 뒤에 또는 else if문 뒤에
    만 사용가능
    3. else문은 모든 조건에 해당없을때
    무조건 실행할 코드가 있을 경우 사용
    ______________________________________________
    
    
[ switch case문 ]
    - 단일조건을 분류하여 실행문을 만들어 줄때 사용하는 제어문
    
    ((구문구조))
    -----------------------------------------------
    switch(변수){
        case 경우1: 실행코드; break;
        case 경우2: 실행코드; break;
        case 경우3: 실행코드; break;
        ...
        default: 실행문;
    }
    -----------------------------------------------
    ((구문해석))
    
    1. 변수값에 해당하는 경우 그 값에 해당하는
    case에 들어가서 실행코드를 실행함
    
    2. 각 case 끝에 break 예약어를 반드시 써야함!
    -> 안쓰면 다른 case에 또 들어가는 경우가 생김!
    -> 일반적으로 break 키워드는 제어문을 빠져나갈때 씀!
    
    3. default 는 if문의 else문과 비슷하여 해당 케이스가 
    없으면 이 부분이 실행됨(단, 필요시 사용)
    -> default문에는 break를 쓰지 않는다!
    ______________________________________________    
    
    
[ for문 ]
    - 어떤 실행문을 순서대로 여러번 반복
    실행할 경우 사용하는 제어문
    
    ((구문구조))
    -----------------------------------------------
    for(시;한;증){실행코드}
    - 시 -> 시작값(변수선언과 함께 숫자할당)
    - 한 -> 한계값(숫자를 조건문으로 사용)
    - 증 -> 증감(1씩증가 ++ / 1씩감소 --)
    _______________________________________________
  
[ for of 문 (배열/컬렉션을 위한) ]

    - 일반for문에 비해 간단한 형식의 for문

    -> 시;한;증 이 필요없다!
    -> 배열/컬렉션 개수만큼 알아서 돌아줌!
    -> ES6에서 새롭게 등장함!

    
    ((구문구조))
    -----------------------------------------------
    for(let 변수 of 배열/컬렉션){실행문}
    -----------------------------------------------
  
    [★ 부가기능 ] 
    문자데이터를 넣으면 한글자씩 돌아줌! 
    for(변수 of 문자데이터변수) {실행문}
    -> 문자데이터변수를 한글자씩 태그로 싸줄때 편리함!
    _______________________________________________

[ for in 문 (객체를 위한) ]

    -> for of문 이나 for Each 메서드는
        배열/ 유사배열만 사용가능하기 때문에
        객체의 순회는 for in문을 사용한다!

    ((구문구조))
    --------------------------------------------
    for(변수 in 객체){코드}
    --------------------------------------------
    
    - 작동원리:
    객체의 개수만큼 순서대로 속성명과 속성값을 가져옴

    - 변수는 객체의 '속성명'이다!

    - 객체의 '값'을 사용하려면 for in 문 안에
        객체[변수] 로 쓰면됨!

        -----------------------------------
        [객체구조가 중첩일때] 
        객체 = {
            속성명: { 속성명 : 값 }
        }
        객체[변수].속성명 하면  객체의 속성값에 해당되는 속성명의 값을 가져옴  
    ________________________________________________

[ while문 ]
    - 반복실행코드를 위한 조건으로 만드는 제어문

    ((구문구조))
    -----------------------------------------------
    시작값;

    while(한계값){
        실행코드;
        증감;
    }
    -----------------------------------------------
    ((구문해석))

    - for문과 유사하나 시작값이 while문 윗쪽에 나옴
    - 한계값은 while문 소괄호 안에 씀
    - 증감은 while 실행코드 내부에 씀
    (주의: 증감을 안쓰면 무한루프에 빠짐!)

    - >>>>> while문과 for문은 무엇이 다른가?
    시작값과 증감없이 단지 조건에 의해서
    반복실행이 필요한 경우 사용할 수 있다!

    while(조건){코드}
    -> 예) 중복숫자 피하기, 직전값 피하기 등
    ______________________________________________ 


[continue / break 예약어] 
    일반적으로 반복문과 switch 문에서 사용

    [ continue 예약어]
        continue  키워드를 for문에 사용하면
        해당 순번은 하단코드를 생략하고
        다시 상단으로 가서 다음순번을 실행한다!

    [ break 예약어 ]
        
        for문에서 break 키워드를 사용하면
        조건에 해당시 만나는순간
        for문을 빠져나간다! (for문 실행 끝!)
______________________________________________ 

    
[ forEach() 배열과 컬렉션을 위한 메서드 ]
 
    forEach()는 
    배열과 컬렉션을 위한 JS메서드임!
    -> ES5에서 새롭게 등장!(배열메서드!)

    
    ((구문구조)) 1. 컬렉션에 사용시
    ----------------------------------
    
    컬렉션.forEach(
        (ele,idx,obj){코드})
        
    ----------------------------------
    전달변수
    1) ele -> 첫번째 전달변수 : 요소자신
    2) idx -> 두번째 전달변수 : 순번
    3) obj -> 세번째 전달변수 : 전체컬렉션
    ________________________________
    
    ((구문구조))  2. 배열에 사용시
    --------------------------------
    
    배열.forEach(
        (val,idx,obj) => {코드})

    --------------------------------
    전달변수
    1) val -> 첫번째 전달변수 : 배열값
    2) idx -> 두번째 전달변수 : 순번
    3) obj -> 세번째 전달변수 : 전체배열
    
    ================================
    공통사항)
    - 전달변수의 순서와 개수가 중요함
    - 전달변수명은 어떻게 지어도 무관
    - 값이나 요소만 쓰려면 변수를 하나만씀
    - 순번까지 쓰려면 변수를 두개씀
    -> 보통 변수를 2개까지 많이 씀
    - 명령어를 사용하여 로직을 수행하는 것은
    함수 중괄호안에 코딩하면 된다!
_____________________________________________    
    
[외부JS호출하기]
    
    <script src="./파일경로.js" defer></scrip>
        - defer키워드로 html코드 로딩후 실행가능
        
    ______________________________________________ 
        
[로딩 후 html 요소 수집방법 3가지]
    
        html요소를 수집하려면 html요소 코드가
        그려진 후 수집해야만 한다!


    1. script구역을 body 최하단에 위치
    2. 외부JS로 만들때 defer 키워드를 쓴다

    3. load 이벤트 함수 구역을 만들고
    그 안에 수집코드를 쓴다


    window.addEventListener('Load', function);

    window.onload = function(){
        console.log('로딩완료!');
    ---------------------------------------------

[ 이벤트 설정하기 ]

    var btn = 
    document.querySelector('.btn');

    btn.addEventListener('click', 이벤트함수이름);

    }; //로딩함수구역

    (버튼이 여러개일때는 
    btn[i]값을 위해 for문 안에서 이벤트설정하기)
    ----------------------------------------------
    ★ 비디오 이벤트: timeupdate -> 동영상 재상 감시 이벤트 
                ★ 비디오요소.paused => 멈춤상태면 true, 아니면 false
                비디오가 멈춤상태(true)면 페이지 이동!
                if (비디오요소.paused){
                        location.href='main.html'; (같은위치일경우)}
                -> JS에서 페이지 이동은 location.href= 주소or페이지 
    ______________________________________________ 

[ 사용자 정의 속성 : 'data-' 로 시작! ]

    -> 사용자가 요소의 속성을 만들어 쓰고자할때
    이름을 'data-'로 시작하면 공식적인 속성으로
    인정된다!

    ______________________________________________ 
    
[ var / let / const :바렛콘스트 ]
    
    [ var : 함수 스코프 ] 함수구역 기준으로 지역/전역변수 나뉨.
    
    (함수내 선언시 함수내에서만 유효)
    
    /재선언 재할당o 
    함수밖 전역변수를 함수내에서 재선언시 지역변수가 됨. (전역변수 연결X)
    함수밖 전역변수를 함수내에서 선언없이 할당하면 전역변수 덮어쓰기 됨
    선언전 사용, 호이스팅유  (var만 됨)
    
    변수선언 A = b
    후에 var A; 이렇게 가능 ->  단점: 코딩순서에 혼란을가져옴(그래서 렛 콘스트나옴)
    
    
    같은 영역에서 같은 이름의 변수를 다시 선언하면 
    재선언하여 관리함(덮어쓰기함!)
    ---------------------------------------------------
    
    [ let / const : 블록스코프 ] {} 중괄호 안에서 선언시 {} 안에서만 유효. 
    
    같은이름으로 전역과 지역 둘다선언시 호출 위치에따라 값이 다름 
    두개는 이름은같지만 다른변수임
    
    
    let은 재할당가능   
    const 재할당x     : 상수(constant) -> 변하지 않는값
    
    둘다 동일지역 내 재선언 불가 (var는 가능)
    선언전 사용X , 호이스팅 x
    
    const는
    1. 선언과 동시에 할당해야함! -> 재할당X (값변경불가)
    2. 배열과 객체, 함수를 상수로 만드는 경우가 많다!
    -> 변경불가는 각 배열형, 객체형, 함수형
    -> 변경가능은 각 배열값, 객체값, 함수전달값
    
    3. 기타의 특징은 let과 동일함!(블록단위변수)
    ____________________________________________________
    
    [ 내장 함수  ]
    내장 함수는 호출될 때 특정 작업을 수행하고 결과를 반환합니다.
    
    [ 내장 객체 ]
    
    내장 객체도 서로 다른 기능과 특성을 가지며, 각각의 객체는 다른 상황에 유용합니다.
    내장 객체는 다양한 작업을 수행할 수 있는 메서드와 속성을 가지고 있습니다.
    
    이러한 비교를 통해, 내장 함수는 특정 작업을 수행하는 함수이며,
    내장 객체는 다양한 기능과 속성을 가진 객체라는 점을 이해할 수 있을 것입니다.   
    ____________________________________________________
    
[ 배열(Array) 변수란? ]
    
        - 여러개의 데이터를 묶음으로 변수하나에 저장함
        - 장점: 데이터를 취급하고 다루는데 편의성 제공
        - 각 데이터를 하나의 이름으로 구분하여 호출할
        수 있는 메모리공간이다!
        (예: 계란한판, 아파트 등)
    
    [ 배열의 선언의 2가지 방식 ]
    
        1. new 키워드 선언방식
        - new Array()
        객체를 실제로 메모리안에 생성하는 방법을 제공
        이를 인스턴스(instance)라고 함!
        
        2. 리터럴 선언방식 (배열리터럴)
        - 변수 = []
    
        ------------------------------------------------
        // 배열 생성
        const array = ['A', 'B', 'C', 'D', 'E'];

        // 배열 요소에 접근하여 값 변경
        console.log(array[0]); // 첫 번째 요소에 접근
        console.log(array[2]); // 세 번째 요소에 접근
        array[1] = 'Z'; // 두 번째 요소를 'Z'로 변경

        // 배열의 길이 확인
        console.log(array.length); // 배열의 길이 출력

        // 배열 메서드 사용
        array.push('F'); // 배열의 끝에 새로운 요소 'F' 추가
        array.pop(); // 배열의 끝에 있는 요소 제거 ('F' 제거)

        array.unshift('0'); // 배열의 시작 부분에 새로운 요소 '0' 추가
        array.shift(); // 배열의 첫 번째 요소 제거 ('0' 제거)

        array.splice(2, 1); // 배열의 인덱스 2부터 시작하여 1개의 요소 제거

        // 배열 순회
        for (let x of array) {
            console.log(x);
        }

        /***************************************************** 
        [ 배열 메서드 정리 ]
        1. push(값) - 뒷배열추가!
        2. pop() - 뒷배열삭제!
        3. unshift(값) - 앞배열추가!
        4. shift() - 앞배열삭제!
        5. splice(순번,0,값) - 중간배열삽입!
        6. splice(순번,개수) - 중간배열삭제!
        _________________________________

        7. join(구분자) - 배열값 구분자로 문자열변환!
        8. map(v=>'<새값>${v}</새값>') - 새배열!(배열리턴,* 홑따자리 백틱임)
        9. forEach(v=>{}) - 배열/유사배열 순회!
        10. Object.keys(객체) - 객체의 키로 배열변환!
        11. Object.values(객체) - 객체의 값으로 배열변환!
         *****************************************************/
         /////////// [ map() 메서드의 특징 ] /////////////
        map((배열값,순번,전체배열)=>{})
        1. 메서드를 사용한 자리에 결과가 배열로 리턴됨
        2. 원본배열은 그대로 보존됨!
        3. 리턴 키워드나 변수, 함수 등 처리방법 불필요
        4. 이를 변수에 할당하면 새로운 배열이 생성됨!
        5. 문자열로 찍어주려면 변수메서드 join()사용!
        -> join('') 빈문자열 결합을 사용하면 배열값이
        깨끗하게 문자열 덩어리로 그대로 출력된다!!!
        ->>> 배열.map().join('') -> 배열 맵쪼잉~!
        -> join()을 안쓰면 배열의 기본값이 콤마로 연결되어
        할당되는데 콤마를 없애려면 반드시 join()을 써야함! 

         /****************************************************** 
    [ JS 배열의 정렬 ]

            -> 용어의 정의: 정렬이란?
            : 배열의 값을 기준으로 순서를 다시 정하는것!
            배열의 정렬은 sort() 메서드 사용!
            sort() 메서드를 사용하여 배열의값을 오른차순,내림차순으로
            정렬할 수 있음!

            [ sort() 메서드의 특징 ]
            1. 기본정렬 :  오름차순(1,2,3,.../a,b,c,...)
                -> 기본 내림차순 메서드 -> reverse()
            2. 원리 : 배열값을 문자열로 캐스팅(형변환)한후
                    변환된 문자열을 비교하여 순서를 결정함
            (참고: undefined 값일 경우 배열 맨뒤에 배치함)
            -> 주의: 숫자를 비교해도 문자열로 비교하기 때문에
            "25"와 "100" 중 큰 숫자는 100이지만 25를 더 큰
            데이터로 인식한다! 
            -> sort() 메서드 비교함수로 처리!

            [ sort() 메서드 비교함수 ]
            -> sort() 메서드 내부에 2개의 전달값을 가지는 함수를 쓰면
            sort메서드 자체에서 값을 비교하여 배열값의 순서를 바꾼다!
            -> 숫자일 경우 빼기 연산을 함!

            숫자데이터배열.sort(function(a,b){return a-b;}) => 오름차순
            숫자데이터배열.sort((a,b)=>a-b) => 오름차순

            숫자데이터배열.sort(function(a,b){return b-a;}) => 내림차순
            숫자데이터배열.sort((a,b)=>b-a) => 내림차순

            -> a는 앞 데이터, b는 뒷 데이터

            [-> 기준정렬 : 오름차순]
            배열변수.sort() -> 기본정렬

            [-> 기준정렬 : 내림차순]
            배열변수.reverse() -> 기본정렬

            ++++++++++++++++++++++++++++++++++++++++++++++

            ->>> 숫자형, 문자형에 무관하게 하나로 처리하기!!!
            [ sort() 메서드만 사용하여 정렬잡기 ]

            ((비교함수사용))
            배열변수.sort(function(x,y){
                if(x>y) return 1;
                if(x<y) return -1;
                return 0;
            })
            
            -> 단순화하기(삼항연산자사용!)

            배열변수.sort(function(x,y){
                return x == y ? 0 : x > y ? 1 : -1;
            })

            -> 더 줄이기! (화살표함수 사용!)

            배열변수.sort((x,y)=> x == y ? 0 : x > y ? 1 : -1)


            -> 리턴값의 의미(오름차순)
            1) if(x>y) return 1; -> x가 y뒤에 옴 (리턴값 양수)
            2) if(x<y) return -1; -> x가 y앞에 옴 (리턴값 음수)
            3) return 0; -> x,y 정렬을 유지 (리턴값 0)

            -> 내림차순은 양수/음수만 반대로 써주면 된다!

            [ 정렬시 데이터 유의사항 ]

            1. 문자형일 경우 대소문자가 섞여있으면 대문자나 소문자중
            하나로 통일하여 비교해야함(toUpperCase()/toLowerCase())

            예)
                배열변수.sort((x,y)=>{
                    let a = x.toUpperCase(),
                        b = y.toUpperCase();
                    
                    return a == b ? 0 : a > b ? 1 : -1;
                })

            2. 날짜정렬도 숫자와 동일함
            (날짜데이터 자체가 숫자형으로 되어있음)

            3. 특정언어의 특수문자일 경우 
            localeCompare() 메서드로 문자열 비교를 한다!

            예) 특수문자 x변수를 y변수와 변환후 비교 
                x.localeCompare(y)

******************************************************/
  arrObj.sort((a, b) => (a == b ? 0 : a < b ? -1 : 1));
    // ((해석)) 
    // 앞값 뒷값 같으면 0, 뒷값이 크면 -1, 앞값이 크면 1
    // 즉, 앞값이 크면 자리를 바꿔서 유지하므로 오름차순정렬

    // ((공통 정렬 처리하기))
    // 문자든 숫자든  sort()메서드의 내부적 처리에서
    // 앞뒤 문자가 같으면 0, 뒷문자가 크면 -1,
    // 뒷문자가 작으면 1로 리턴값을 처리하면 된다!
    // -> [숫자 시그널]:
    // 0 아무것도 안함,1 바꿔서 유지,-1 그대로 유지

    // -> [내부적 처리란?]
    // 문자일 경우 '가'>'나' 1 로 처리할 경우
    // '나','가'  로 순서를 바꿔서 처리함(내림차순)
    // 즉, 문자열도 순서대로 글자 알파벳, 가다나라 순
    // 등 특정순서기준이 브라우저에 구현되어 있음!

    // 빼기처리는 문자 등 기타 데이터는 처리불가함!
    // sort() 빼기연산처리 : 앞수-뒷수
    // (양수결과일경우 순서바꾸기함!)
    // arrObj.sort((a,b)=>a-b);
        _________________________________________________
        
        [ 객체(Object) 란? ]
        
        - 객체란 속성과 메서드를 가지고 있는 프로그램 단위체
        - 객체는 독립된 특성을 가지고 있어야함!
        
        예컨데 자동차, 볼펜, 물통, 가방 등
        독립된 별도의 기능이 있어야하고 명사적특징과
        동사적 특징이 모두 있어야 객체다!

        - 일반적으로 JS에서 객체란 속성과 메서드를
        가지는 프로그램 단위체
        - 속성은 명사적 특징, 메서드는 동사적 특징
        객체예)
        https://www.w3schools.com/js/js_objects.asp
        - 자동차의 명사적특징: 핸들, 백미러, 트렁크, 바퀴 등
        - 자동차의 동사적특징: 운전하다, 멈추다, 주차하다 등
        
        (참고: 브라우저에 이미 만들어져 있는 객체들)
        -> 내장객체라고함!
        -> 브라우저 내장객체-> 봄(BOM:Browser Object Model)
        -> https://www.w3schools.com/js/js_window.asp
        
        window : 윈도우(브라우저화면) 표시 관련객체
        document : 문서구조에 관련된 객체
        Array : 배열객체
        Object : 객체를 만들기 위한 객체
        Date : 날짜객체
        Math : 수학객체
        ___________________________________

        ->>> 내장객체 중 객체를 만들기위한 객체인 Object를
        사용하여 객체를 만들어보자!
        
    [ 객체의 선언의 2가지 방식 ]
        1. new 키워드 선언방식
        - new Object()
        
        2. 리터럴 선언방식(객체리터럴)
        - 변수 = {}
        
    [ 객체의 할당 ]
        - 중괄호{}를 사용하여 할당코딩을 함
        - {속성명:값,속성명:값,...}
        - 여러값을 셋팅할때 콤마로 구분한다
        - 배열과 비교해서 이해하기 쉽고 호출하기 쉽다!
        - 객체 스타일로 데이터 구조를 만들고
        이런 파일로 DB와 데이터 통신을 한다!
        이 파일의 이름은? 제이슨(JSON:확장자.json)
        
    [ ★★★ 객체의 호출 ]  //객체의 속성이 문자형or변수형 둘다 사용가능
        - 객체명["속성명"] 
        또는
        - 객체명.속성명

    [ new 키워드 없이 바로 객체 생성하기 ] 
        -> 객체 리터럴 (추천방식!)

        - 방법: 변수 선언 후 이퀄 뒤에 바로 중괄호 사용!
        예) let obj = {속성명:값,속성명:값,...};

    [ 객체의 속성 셋팅시 
    문자형 또는 변수형 사용하기 ]
        
        1. 문자형 속성 - 따옴표로 싸는 방법

        예) let obj = {"나는나":"호호호","너는너":"하하하"}
        -> 문자형 속성의 객체 호출시
        객체명[문자형속성명]
        예) obj["나는나"]

        2. 변수형 속성 - 따옴표로 안싸는 방법
        예) let obj = {name:"김수현",tall:"186cm"};
        -> 변수형 속성의 객체 호출시
        객체명.속성명
        예) obj.name

        또는

        객체명["속성명"]

예) obj["name"]
-> ★★★반드시 변수형 속성명을 따옴표로 싸서
        문자형으로 표시해야함!
        obj[name] -> 에러남!

        -> 만약 문자형으로 설정된 경우에도
        변수형으로 사용될 수 있는 문자면 변수형호출가능!
        예) var obj = {"하하하":"나나나"}
            obj["하하하"] 또는 obj.하하하


            ******
[ 객체의 배열화 ] 
    - 프론트앤드에서 다루어지는 데이터 중 
        객체로 구성된 데이터가 많다.
    
    - 개발자가 이 데이터를 순회하며 화면에 태그를 구성할 때
        객체의 값만 순회하여 사용하는 경우가 많다! 
        
        내가 변경하기 어려운 객체데이터를 배열데이터로 변경하면
        배열 메서드를 쉽게 사용할 수 있다!
    _________________________________________________
    객체{key:value,key:value,key:value,....}
    - 속성들 keys() 메서드  -> 배열화
    - 값들 values() 메서드  -> 배열화

        
    [1] 객체의 속성을 배열로 만들기 
        Object는 객체를 만드는 최상위 객체 
        Object.keys(객체) -> 속성명으로 된 배열 
        

    [2] 객체의 속성값을 배열로 만들기 
        Object는 객체를 만드는 최상위 객체 
        Object.values(객체) -> 속성값으로 된 배열 
        

    [3] 배열화하여 사용하는 방법  
        객체의 속성 또는 값 중에 원하는 부분을 배열화하여
        변수에 담고, 이를 배열메서드를 사용한 코드로 변환작업을 해준다! 

    ---------------------------------------------------
    // 객체 생성
    const obj = {
        key1: 'Value1',
        key2: 'Value2',
        key3: 'Value3',
        key4: 'Value4',
        key5: 'Value5'
    };

    // 객체 속성에 접근하여 값 변경
    console.log(obj.key1); // 첫 번째 속성에 접근
    console.log(obj.key3); // 세 번째 속성에 접근
    obj.key2 = 'New Value'; // 두 번째 속성의 값을 변경

    // 객체의 속성 개수 확인
    console.log(Object.keys(obj).length); // 객체의 속성 개수 출력

    // 객체 메서드 사용
    delete obj.key5; // 특정 속성 제거
    obj.newKey = 'New Property'; // 새로운 속성 추가

    // 객체 순회
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            console.log(obj[key]);
        }
    }

    // Object.keys()를 사용하여 속성을 배열로 가져오기
    const keysArray = Object.keys(obj);
    console.log(keysArray);

    // Object.values()를 사용하여 값들을 배열로 가져오기
    const valuesArray = Object.values(obj);
    console.log(valuesArray);

    // Object.entries()를 사용하여 [key, value] 쌍의 배열을 가져오기
    const entriesArray = Object.entries(obj);
    console.log(entriesArray);

    // Object.assign()을 사용하여 객체 병합
    const anotherObj = {key6: 'Value6', key7: 'Value7'};
    const mergedObj = Object.assign({}, obj, anotherObj);
    console.log(mergedObj);

            
_______________________________________________________
   
[ 타이밍 함수 (Timing Function) ]

    -> 일정시간 후 자동호출 기능의 JS내장함수

1. 인터발함수 : setInterval(함수,시간)

    예) setInterval(function(){코드},3000)
        -> 3초간격으로 코드실행!
        _______________________________________
        
2. 타임아웃함수 : setTimeout(함수,시간)

    -> 설정된 시간 후 함수를 한번만 호출함!
    예) setTimeout(function(){코드},800)
        -> 0.8초후 코드 한번만 실행!
        _______________________________________
        
        (( 인터발함수/타임아웃함수를 지우는 함수는? ))
        1. 인터발함수 : clearInterval(인터발변수)
        2. 타임아웃함수 : clearTimeout(인터발변수)
        _______________________________________
        

        -> 함수가 외부에 있을 경우 
        그 함수명만 써서 함수를 등록

        외부함수) 
        function hahaha(){코드}
            
        setInterval(hahaha,2000);
        ___________________________

        -> 외부함수가 전달값이 있을 경우
            익명함수 구역 안에서 코드를 작성한다!

        외부함수 전달값o) 
        function hahaha(txt){코드}

        setInterval(function(){
            hahaha("넌누구냐?");
        },2000);
_______________________________________________________

[[ 이벤트발생시 위치값 ]]

1. pageX, pageY
-> 전체 문서를 기준(스크롤 화면을 포함)
-> 화면을 기준한 absolute 포지션에서 주로 사용!

2. clientX, clientY
-> 현재 보이는 브라우저 화면이 기준
-> 화면을 기준한 fixed 포지션에서 주로 사용!

3. screenX, screenY
-> '모니터' 화면을 기준

4. offsetX, offsetY
-> 이벤트 대상이 기준
-> 특정박스이 부모자격박스로 부터 위치를 사용할 경우

    console.log
    ('pageX:',e.pageX,'/pageY:',e.pageY,'"전체문서" (스크롤포함)');
    console.log
    ('clientX:',e.clientX,'/clientY:',e.clientY,'현재 "보이는 브라우저 화면" 기준');
    console.log
    ('screenX:',e.screenX,'/screenY:',e.screenY,'"모니터화면"기준');
    console.log
    ('offsetX:',e.offsetX,'/offsetY:',e.offsetY,'이벤트대상이 기준 \n(부모자격박스로 부터 위치를 사용할 경우)');

_______________________________________________________
부모요소.appendChild(요소)
         ->원래  뒤에 요소 추가기능임
         -> 기존 있는 요소를 선택시
         맨뒤로 이동함
         맨 앞요소를 선택하여 맨뒤로 보냄
         ex) slide.appendChild(slide.querySelectorAll("li")[0]);

부모요소.insertBefore(넣을요소,기준요소) <-기준요소 앞으로 보냄 
        ex)  slide.insertBefore(list[list.length - 1], list[0]);
        list마지막순번을 기존 0번(맨앞)의 앞으로 보냄 

x.parentElement x의 상위 부모요소
_______________________________________________________
[ 화살표함수 ] 를 사용할때

    this 키워드의 의미는 다르다!!!
    
    화살표함수에서 this는 window객체를 의미!
    (자신을 생성한 객체를 가리킨다!
    즉, 여기서는 window로딩구역안에 생성되어서
    window객체를 가리키고 만약 이것이 어떤
    Object안에 메서드라면 그 Object를 가리킴!)
    -> JS this키워드를 자세히 알아볼것임!!!
    
    this 키워드 대신
    event.currentTarget 을 사용하여
    현재요소 자신을 의미하도록
    코딩해야함!
    
_______________________________________________________
[ 코드랩핑 ]
로딩시 바로 실행됨 ->실행코드를 지역화하고자 할때
함수로 만들고 이를 호출하면 됨. 그러나 불편함!
익명함수를 만들고 바로 실행하게 하면 됨!
방법 : (익명함수)()  -> 바로 실행됨!
실제코드 : (()=>{코드})()
실제코드 : (function()=>{코드})()
-> 이러한 처리방법을 코드의 지역화 또는 코드랩핑이라고 부르기도함
목적 : 다른 변수, 함수 충돌방지


    `</script>
<body>
</body>
</html>