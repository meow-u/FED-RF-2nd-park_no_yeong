<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>react</title>
</head>
<script>` 
  [ 리액트란? ] 

-> 프론트엔드 JS 라이브러리다!
-> 사용자 UI의 구성요소를 빌드(html구조와 언어에 데이터를 바인딩하여
배포하는 작업)하기 위한 도구

[ 작동원리 ]
-> 가상돔(Virtual DOM)을 사용하여
최소의 html리소스를 사용함으로
빠르고 쉽게 UI화면을 구성한다!

-> 가상돔은 실제 DOM을 변경하기전에
메모리상에서 구현하는 오브젝트 DOM이다!
-> 변경사항을 단위별로 한번에 업데이트하기위한
수단으로써의 도구다!

______________________________

[ 리액트 구현의 2가지 스타일 ]

# 스타일1 : 리액트는 JS 라이브러리 이므로
필요한 부분에만 적용한다!
-> 라이브러리는 CDN방식으로 구현
(별도의 설치가 필요없다!)

# 스타일2 : 리액트는 
SPA(Single Page Application)이므로
Node.js 등을 사용하여 한 페이지로만 구현하는
웹을 만들 수 있다!
-> Node.js, 리액트 SPA 개발환경 설정이 필요함!
____________________________________________________________

01.시작하기 리액트 JS

JSX에서의 속성 작명은 JavaScript의 관례를 따르며 (camelCase)를 사용한다.
html 태그와 JS문법을 따옴표없이 사용하는 JSX문법을 사용한다!

리액트에서 자바스크립트와 대소문자 규칙이 다른 주요 부분은 다음과 같습니다. 
컴포넌트 이름 리액트 컴포넌트의 이름은 대문자로 시작해야 합니다. 
(예: function MyComponent() {...}) 이는 리액트가 소문자로 시작하는
태그를 HTML 태그로 인식하기 때문입니다. 
JSX 프로퍼티 JSX에서 HTML 어트리뷰트 같은 프로퍼티 이름은 camelCase
네이밍 규칙을 따라야 합니다. (예: className, tabIndex 등) 
이는 일부 HTML 어트리뷰트가 자바스크립트의 예약어와 충돌하기 때문입니다. 
이벤트 이름 앞서 말씀드린 것처럼, JSX에서 이벤트 이름의 첫 글자는 대문자로 시작합니다. (예: onClick, onSubmit 등) 

그 외에는 자바스크립트의 일반적인 네이밍 규칙을 그대로 따릅니다. 
변수, 함수, 객체 프로퍼티 등은 camelCase 네이밍 규칙을 따릅니다. 예약어, 내장 객체 이름 등은 모두 소문자를 사용합니다. 

요약하면, 리액트에서는 컴포넌트 이름, JSX 프로퍼티, 이벤트 이름에 한해서만 자바스크립트와 대소문자 규칙이 다르며, 
이는 JSX 문법과 호환성을 위한 것입니다.
____________________________________________________________

JSX(Javascript XML) 문법을 쓰는 파일은 .js대신 .jsx확장자사용!
    -> return 키워드 사용은 따옴표없이 바로 소괄호롤 묶어사용
    (소괄호 생략 가능!)

    [[ 주의사항 ]]
    1. 함수를 만들경우 반드시 대문자로 시작해야 호출됨!(정해진규칙)
    2. 홀로태그를 사용할때는 마지막에 스스로 닫기를 꼭 해줌!(/>)
    3. 함수 내부의 리턴값으로 만든 요소는 반드시 최상위요소가 하나여여함!
    -> div와 같은 태그로 최상위를 만들어서 내보내기를 한다
    -> 그런데 이런 불필요한 태그구조를 원치 않는경우 
    <React.Fragment></React.Fragment>를 사용하면
    내보낼때 하나로 묶는 역할만 하고 실제로 태그는 출력안됨!
    (참괴: CLI(커맨드라인인터페이스)환경에서는 빈태그를 대신사용가능 <> </> )
리액트 html대상요소에 삽입하기
 가상돔을 셋팅하는 리액트 객체를 호출한다! -> ReactDOM
    render() -> 요소를 변경하는 메서드

[호출형태]
ReactDOM.render(요소를 리턴하는 함수명으로 된 홀로태그또는 출력할코드,대상요소)
__________________________________________

함수명이 MyFirstReact이므로 
요소를 리턴하는 함수명으로 된 홀로태그는? <MyFirstReact />

그리고 대상요소는 JS문법으로 요소를 선택함!
document.querySelector("#root")

__________________________________________

JS ES6버전 문법 사전체크

아래 8가지 ES6버전의 문법이 리액트에서
주요하게 사용된다!
1. 클래스 : JS5-1.1, JS5-1.2
2. 화살표함수 : JS5-2
3. 새로운 변수선언 : JS2-2
4. 배열 메서드 : map()
-> 배열을 자동으롤 돌면서 목록을 만들어 준다!
5. JS JS 비구조화 할당(구조분해할당)
-> 배열의 값을 각각의 변수에 담는 방법
6. 모듈 문법 : 03.JS모듈
7. 삼항연산자 : JS2-1
8. 스프레드 연산자 : ... 
(점3개로 표시 -> 배열/객체값 순서표시)
-> 기본 배열/객체 전체나 일부를 배열이나 객체로
빠르게 복사!!!
__________________________________________

★따옴표없이 사용
★ 함수를 만들경우 반드시 대문자로
★ 함수 내부의 리턴값으로 만든 요소는 반드시 최상위요소가 하나
=> 불필요한 태그구조를 원치 않는경우 
★ <React.Fragment></React.Fragment>를 사용
★ ReactDOM.render(출력할요소, 대상요소)
ReactDOM.render() 함수의 첫 번째 인자로는 JSX를 반환하는 함수명이나 
JSX 코드 자체를 전달할 수 있습니다.

__________________________________________

[ 두 컴포넌트를 포함하는 부모컴포넌트를 만들어서 출력하기 ]
function ParentComponent() {
    return (
        <div>
            <MyFirstReact /> {/* 첫번째 서브컴포넌트 */}
            <MyFirstReact2 /> {/* 두번째 서브컴포넌트 */}
            </div>
        );
    }
    
    부모컴포넌트를 출력하기 
    ReactDOM.render(<ParentComponent />,
    
    리액트의 map()메서드는 리액트 전용
    백틱x, 달러중괄호도 ->{}로, join도 안써도 
    태그가 그대로 클린하게 출력된다
__________________________________________
    
[ 요소 생성방법 2가지 ]

=> JSX로 생성한 엘리먼트 <<< 이걸 많이 사용함
★★ const myEle2 = <h1>ㅋㅋ</h1>;

=> React.createElement()로 생성한 엘리먼트 <<< 잘 안씀!
const myEle1 = React.createElement("h1", {}, "ㅋㅋ");

    
    
[ 출력방식 2가지 ]
★★ ReactDOM.render() 메서드 사용한 방법 <<< 이걸 많이 사용함!
ReactDOM.render(myEle1, target);


ReactDOM.createRoot() 메서드 사용한 방법 <<< 잘 안씀!
root1 = ReactDOM.createRoot(대상요소);
root1.render(myEle1);
______________________________________________

[ JSX 표현식 ]
JSX를 사용하면 중괄호에 표현식을 작성할 수 있다
{........ 표현식 ........}

-> 표현식이란 어떤 값으로 이행하는 임의의 유효한 
코드 단위를 말한다! 
즉, 코드가 값으로 변환되는 JS코드를 표현식이라고 한다.

((개념이해))
예컨데 삼항연산자는 그 자리에 값을 출력할 수 
있으므로 표현식이지만
if문은 코드 전개구문이고 값이 출력되는 코드가 아니므로
표현식이 아니다. 또 어떤값을 할당하는 코드도 할당행위만
있고 값출력이 없으므로 표현식이 아니다!
함수 자체는 표현식이 아니지만 리턴코드를 가진 함수를
호출하는 코드는 값을 찍어주기 때문에 표현식이다!

참고: 
표현식(Expression)과 대비되는 코드를 
문장(Statement)이라고함

______________________________________________
[ JSX에서 속성 클래스는 className 으로 표기한다! ]
<태그 class="클래스명">
class는 JS에서 키워드이므로 사용못함! 대신...
<태그 className="클래스명">

-> 리액트 버전 16부터 class라고 써도 자동 변환하여 
사용가능하다!

______________________________________________

[ 리액트 컴포넌트 ]
대문자로 시작하고 리턴을꼭 포함!! <- 컴포넌트
    - 컴포넌트는 HTML요소를 반환하는 함수다!

    [ 특징 ]
    1. 컴포넌트는 독립적이고 재사용이 가능한 코드집합
    2. JS함수와 비슷하지만
        HTML코드 반환이 필수라는 점이 다름!
    3. 컴포넌트는 다음 2가지로 생성가능함
        1) 클래스형 컴포넌트 
        2) 함수형 컴포넌트 
        (-> 우리는 함수형 컴포넌트에 집중할 예정!)

    -> 클래스형 컴포넌트는 리액트 초중기에 주로 
    사용되었으나... React 16.8버전에서 Hooks와 
    함께는 더 이상 사용되지 않는다! 
    Hooks는 함수형 컴포넌트에서만 사용가능하다! 

    ____________________________________________

    [ 첫번째 컴포넌트 만들기! ]
    - 리액트 컴포넌트 이름은 반드시 첫글자가 대문자로 만든다!
    (안지키면 적용안됨!!!)

    ____________________________________________

    [ 1. 클래스 컴포넌트 ]
    클래스 컴포넌트에서는 
    extends React.Component 상속문이 포함돼야함!
    그리고 return을 쓰기전에 render()메서드를 
      사용해야함! (return을 쓰기위해)

    -> 컴포넌트에서도 메서드가 필요함
    render() 메서드는 HTML을 반환함
    (함수형 컴포넌트의 return 키워드를 
        사용할 수 있는 역할을 함!)

____________________________________________

   [ 2. 함수형 컴포넌트 ]
   - 함수형 컴포넌트는 render 메서드가 없어도 return을 사용할 수 있다! 
   
   - 함수형 컴포넌트는 클래스형 컴포넌트보다
      선언이 간단하고 사용하기 편하다!

   -> 함수형 컴포넌트는 React 16.8버전부터 Hooks를 사용하여 클래스형 컴포넌트와 동일한 기능을 사용할 수 있게 되었다!

   -> React 팀에서도 새로운 컴포넌트는 함수형 컴포넌트로 작성하는 것을 권장하고 있다!

   ____________________________________________
    컴포넌트는 태그형으로 < MakeImage> 호출하면서 
       <MakeImage>태그안에서 속성에 값을 할당해서 보냄  
       ex) <MakeImage isrc="ab1.jpg" ialt="아이언맨"/> 
       <MakeImage> 태그안에 해당컴포넌트 속성값을 바로쓸수잇음 (개발자가 편히쓰라고 태그형으로 만듬) 
        
    (1). 문자열 연결 연산자 (+)를 사용하는 방법: 
    <img src={"./images/" + isrc} alt={ialt} />

    (2). 템플릿 문자열을 사용하는 방법: << 이게 더편함
    <img src={'./images/${isrc}'} alt={ialt} />   <- 여기서 '는 백틱임(오류안나게하려고) 
    (백틱은 키보드 1왼쪽에 있는 키임!

    (3). 변수를 사용하는 방법:
    
    -> 비구조화할당(구조분해할당)을 사용하여
    전달객체를 개별변수값으로 처리할 수 있다!

    [ Props 사용하기 ] -> props라고 지은 변수명은 맘대로쓸수잇음
    props는 properties 에서 나온말
    속성들... 즉, 변수에 값을 할당하여 전달하는 방법
    함수의 전달값과 같고 속성으로 컴포넌트에 보낸다!

    -> 컴포넌트에 중괄호를 사용하면 개별적인 속성변수를 
    전달 받을 수 있다. (구조분해할당방식!)

    /*************************************************** 
    [ 컴포넌트의 파일분리 ]
    리액트는 코드를 재사용하는 것이므로
    컴포넌트를 별도의 파일로 분할 하는것 일반적이다!

    {분할방법}
    1. jsx의 새파일을 생성한다.
    2. 대문자로 시작하는 컴포넌트를 구현한다.
    3. 분할구현된 jsx파일을 import하여 호출한다.

    -> 일반적으로 js파일 상단에 import 키워드로 불러오면
    되는데 지금 사용하는 CDN방식의 바벨모듈에서는
    주의 사항이 있으니 참고 바란다!(아래참고)

***************************************************/
/************************************************* 
[ 바벨을 사용할때 모듈로 파일 호출시 주의사항! ]
  ____________________________________________

  설치형이 아닌 CDN방식의 바벨은 호출셋업의 시차로
  바로 모듈을 호출하면 에러가 발생한다!
  따라서 모듈을 사용할 파일을 아래와 같은 형식으로
  메인 html 상단에 호출해 줘야만 한다!!!

  -> 상단에 모듈화한 JS를 먼저 불러준다!

  <스크립트 src="모듈화한js" 
  data-plugins="transform-es2015-modules-umd" 
  type="text/babel"></스크립트>

  -> 아래쪽에 모듈을 호출하는 JS를 불러준다!

  <스크립트 src="모듈을 호출하는 JS" 
  data-plugins="transform-es2015-modules-umd" 
  type="text/babel"></스크립트>

  ->>> 위의 호출 속성 중 기본적으로
  type="text/babel" 은 당연히 해야하고

  ->>> 여기에 더하여 하나의 속성을 추가한다!
  data-plugins="transform-es2015-modules-umd"

  이 속성과 값이 바벨에서 모듈을 사용하게 하는
  es2015 즉 ES6버전에서의 모듈문법을 사용하게끔 해준다!
*************************************************/

************************************************************* 
    [ 리액트 이벤트 ]
    1. 일반 HTML DOM 이벤트와 마찬가지로 사용자이벤트 사용가능함
    2. 이벤트 종류: click, change, mouseover 등 일반이벤트
    3. 이벤트 표기법: 캐믈케이스 - 첫글자소문자 단어마다 대문자
    예) onclick -> onClick
    4. 이벤트 핸들러 : 중괄호 안에 작성(중괄호는 JSX표현식영역)
    예) onclick="getIt()" => onClick={getIt}
    5. 리액트에 속성 형태로 등록하는 이벤트는 html 요소에 등록된
    이벤트 속성과 달리 JS 이벤트 리스너를 통한 이벤트 객체에
    등록되므로 html 태그상 이벤트 등록 속성이 보이지 않는다!

    [컴포넌트 호출시 중요한 특징 하나!!!]
    ->>> 설정된 전달변수와 세팅 속성은 전달된 속성값만 세팅된다!
    쉽게 말해 보내주지 않은 속성은 스킵(skip!!!)된다는 말!
************************************************************

    
    `</script>
<body>
</body>
</html>